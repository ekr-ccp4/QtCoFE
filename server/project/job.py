#!/usr/bin/python

#  ------------------------------------------------------------------
#    Job class. Jobs are actual directories that host job data. Job
#  class contains all relevant metadata.
#  ------------------------------------------------------------------

import os
from varut  import gitut, jsonut, utils, defs

class Job(jsonut.jObject):

    def __init__ ( self,json_str="" ):
        super(Job,self).__init__(json_str)
        if json_str:
            self.__data_from_json()
        return

    def __data_from_json ( self ):
        for i in range(len(self.data)):
            for j in range(len(self.data[i])):
                self.data[i][j] = jsonut.jObject(self.data[i][j])
        return

    def set_minimal_data ( self,name,desc,type,parentId,jobId ):
        self.name     = name   # if empty then taken from task
        self.desc     = desc   # if empty then taken from task
        self.type     = type   # task type
        self.parentId = parentId
        self.id       = jobId
        self.jobs     = []     # child job(s)

        self.data     = []     # data (represented by metadata)
                               # generated by the job
        # all data is arranged in lists like in the following:
        # data = [[data11,data12,...],
        #         [data21,data22,...],
        #         ....................
        #        ]

        self.expanded = True
        return


    def add_data ( self,data_class ):

        for i in range(len(self.data)):
            if self.data[i][0].type == data_class.type:
                self.data[i].append ( data_class )
                return

        self.data.append ( [data_class] )
        return


    def set_data ( self,data_class_list ):

        for i in range(len(self.data)):
            if self.data[i][0].type == data_class_list[0].type:
                self.data[i] = data_class_list
                return

        self.data.append ( data_class_list )
        return

    def to_JSON(self):
        data1 = []
        for i in range(len(self.data)):
            data1i = []
            for j in range(len(self.data[i])):
                data1i.append ( self.data[i][j] )
                self.data[i][j] = self.data[i][j].to_JSON()
            data1.append ( data1i )
        json_str = super(Job,self).to_JSON()
        self.data = data1
        return json_str


    def read ( self,project_repo_dir,jobID ):
    #  Lock repository before calling this function

        if not os.path.isdir(project_repo_dir):
            return utils.make_return ( "","no_project_repo_dir",
                                  "Project data repository not found" )

        result = gitut.checkout ( project_repo_dir,[] )
        if result.result != "OK":
            return result

        super(Job,self).read_json ( open (
            os.path.join ( project_repo_dir,"job." + str(jobID),
                                        defs.job_data_name())).read() )
        self.__data_from_json()

        return utils.make_return ( "","OK","OK" )


    def write ( self,project_repo_dir ):
        file = open ( os.path.join(project_repo_dir,"job." + str(self.id),
                               defs.job_data_name()),"w" )
        file.write ( self.to_JSON() )
        file.close ()
        return


#
#  ------------------------------------------------------------------
#   Tests
#  ------------------------------------------------------------------
#

if __name__ == "__main__":
    import sys
    from varut import jsonut
    from   dtypes import sequence, hkl

    J = Job()
    J.set_minimal_data ( "job-name","job-desc","job-type",0,1 )
    print "\nJob:\n\n" + J.to_JSON()

    seq      = sequence.DType()
    seq.file = "sequence.seq"
    J.set_data ( [seq] )
    print "\nJob:\n\n" + J.to_JSON()

    hkl_data  = hkl.DType()
    hkl_data.file = "merged.mtz"
    J.add_data ( hkl_data )
    print "\nJob:\n\n" + J.to_JSON()

    json_str = J.to_JSON()
    print "----------------------------------------------------------"

    B = Job(json_str);
    print "\nB:\n\n" + B.to_JSON()
    print B.data[0][0].type
    print B.data[1][0].type


    sys.exit(0)
